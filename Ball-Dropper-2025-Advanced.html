<!DOCTYPE html>
<html>
<head>
    <title>Polygon Ball Dropper</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #e0e0e0; }
        #gameContainer {
            position: relative;
            width: 406px;
            height: 760px;
            overflow: hidden;
            background: #a0a0a0;
            border: 1px solid #555;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        canvas {
            position: absolute;
            top: 60px;
            left: 0;
            cursor: crosshair;
            z-index: 5;
        }
        #playAreaBackground {
             position: absolute;
             top: 60px;
             left: 25px;
             width: 356px;
             height: 700px;
             background: #f0f0f0;
             z-index: 1;
             border-left: 1px dashed #888;
             border-right: 1px dashed #888;
         }
        #marqueeBanner { position: absolute; top: 0; left: 0; width: 100%; height: 30px; background: #0066cc; color: white; font-family: Arial, sans-serif; font-size: 20px; text-align: center; line-height: 30px; z-index: 11; }
        #banner { position: absolute; top: 30px; left: 0; width: 100%; height: 30px; background: #333; color: white; font-family: Arial, sans-serif; font-size: 20px; text-align: center; line-height: 30px; z-index: 10; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Arial Black', Gadget, sans-serif; font-size: 50px; font-weight: bold; color: #CC0000; display: none; text-align: center; text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.6); z-index: 100; width: 90%; }
        #scoreDisplay { position: absolute; top: 65%; left: 50%; transform: translate(-50%, -50%); font-family: Arial, sans-serif; font-size: 26px; font-weight: bold; color: #CC0000; display: none; text-align: center; text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5); z-index: 100; }

    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="marqueeBanner">Tracy's Ball Droppers</div>
        <div id="banner">Score: 0 | Balls: 1 | Round: 1</div>
        <div id="playAreaBackground"></div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameOver">GAME OVER</div>
        <div id="scoreDisplay">Score: 0</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        try {
            const Engine = Matter.Engine, Render = Matter.Render, World = Matter.World, Bodies = Matter.Bodies, Events = Matter.Events, Vector = Matter.Vector;

            const engine = Engine.create({
                timing: { timeScale: 1 },
                positionIterations: 12,
                velocityIterations: 12
            });
            const world = engine.world;
            engine.gravity.y = 1.0;

            const CONTAINER_WIDTH = 406;
            const PATHWAY_WIDTH = 25;
            const PLAY_AREA_WIDTH = 356;
            const PLAY_AREA_LEFT = PATHWAY_WIDTH;
            const PLAY_AREA_RIGHT = PLAY_AREA_LEFT + PLAY_AREA_WIDTH;
            const CANVAS_WIDTH = CONTAINER_WIDTH;
            const CANVAS_HEIGHT = 700;
            const TOP_UI_HEIGHT = 60;
            const ROW_HEIGHT = 80, MAX_OBJECTS = 120, POLYGON_SPACING = 32;
            const POLYGON_RADIUS = 20;
            const HOPPER_Y = 20;
            const HOPPER_TARGET_Y_OFFSET = 5;
            const HOPPER_TARGET_X_OFFSET = 15;
            const HOPPER_CENTER_X = CONTAINER_WIDTH / 2;
            const BALL_RADIUS = 7.5;
            const LAUNCH_POINT_Y = HOPPER_Y + BALL_RADIUS + 10;
            const LAUNCH_MAGNITUDE = 16;
            const CAGE_Y_POSITION = LAUNCH_POINT_Y + 20;
            const CAGE_GAP_WIDTH = 36;
            const CAGE_LINE_WIDTH = 2;
            const FIXED_START_X = HOPPER_CENTER_X;
            const RETURN_BALL_SPEED_VERTICAL = 11.4;
            const RETURN_BALL_SPEED_HORIZONTAL = 10.5;
            const HORIZONTAL_TRANSITION_Y = HOPPER_Y + BALL_RADIUS + 5;

            const LAUNCH_STAGGER_MS = 10; // Reduced stagger

            const render = Render.create({
                element: document.getElementById('gameContainer'),
                engine: engine,
                canvas: document.getElementById('gameCanvas'),
                options: {
                    width: CANVAS_WIDTH,
                    height: CANVAS_HEIGHT,
                    wireframes: false,
                    background: 'transparent'
                }
            });
            if (!render.canvas) throw new Error("Canvas failed to create");
            render.canvas.style.top = `${TOP_UI_HEIGHT}px`;

            const defaultCategory = 0x0001, ballCategory = 0x0002;

            let score = 0;
            let activeBalls = [];
            let returningBalls = [];
            let hopperBalls = [];
            let polygons = [];
            let nextReturnPathway = 'left';
            let gameOver = false, aiming = false, turnInProgress = false, isPausing = false;
            let launchInProgressFlag = false; // New flag
            let startPos = { x: FIXED_START_X, y: LAUNCH_POINT_Y };
            let round = 1;
            let currentLaunchCount = 0;
            let nextRoundBallCount = 1;
            let rowCount = 0;
            let launchDirection = null;
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96c93d', '#ffa502'];
            const DIAMOND_COLOR = '#000000', ACTIVE_BALL_COLOR = '#ff4500', USED_BALL_COLOR = '#808080';
            let fadeAlpha = 0, fadeDirection = 1, scoreFlashInterval = null;
            const STUCK_SPEED_THRESHOLD = 0.15;
            const STUCK_ESCAPE_ZONE_Y = CANVAS_HEIGHT - 40;
            const STUCK_KICK_VY_MIN = -0.8;
            const STUCK_KICK_VY_RAND = 1.0;
            const STUCK_KICK_VX_AMP = 0.5;
            let pauseResumeGraceTicks = 0;
            const PAUSE_RESUME_GRACE_TICKS_TOTAL = 5;
            let isSpedUp = false;
            let lastRightClickTime = 0;
            const DOUBLE_CLICK_THRESHOLD = 500;
            let ballsPendingReturnSetup = [];
            let endTurnPending = false;

            function updateBanner() {
                 document.getElementById('banner').textContent = `Score: ${score} | Balls: ${nextRoundBallCount} | Round: ${round}`;
            }

             function interpolateHexColor(color1, color2, factor) {
                factor = Math.max(0, Math.min(1, factor));
                const c1 = parseInt(color1.substring(1), 16);
                const r1 = (c1 >> 16) & 255, g1 = (c1 >> 8) & 255, b1 = c1 & 255;
                const c2 = parseInt(color2.substring(1), 16);
                const r2 = (c2 >> 16) & 255, g2 = (c2 >> 8) & 255, b2 = c2 & 255;
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1).padStart(6, '0')}`;
            }

            World.add(world, [
                Bodies.rectangle(PLAY_AREA_LEFT + 2, CANVAS_HEIGHT / 2 + TOP_UI_HEIGHT/2, 4, CANVAS_HEIGHT, { isStatic: true, restitution: 0.9, friction: 0.0, collisionFilter: { category: defaultCategory, mask: ballCategory }, render: { visible: false } }),
                Bodies.rectangle(PLAY_AREA_RIGHT - 2, CANVAS_HEIGHT / 2 + TOP_UI_HEIGHT/2, 4, CANVAS_HEIGHT, { isStatic: true, restitution: 0.9, friction: 0.0, collisionFilter: { category: defaultCategory, mask: ballCategory }, render: { visible: false } }),
                Bodies.rectangle(HOPPER_CENTER_X, CANVAS_HEIGHT + 30, PLAY_AREA_WIDTH, 60, { isStatic: true, isSensor: true, label: 'bottomSensor', collisionFilter: { category: defaultCategory, mask: ballCategory }, render: { visible: false } })
            ]);

            function createBallBody(x, y, isHopperBall = false) {
                 const ball = Bodies.circle(x, y, BALL_RADIUS, {
                     restitution: 0.95, friction: 0.001, frictionStatic: 0.01, frictionAir: 0.005,
                     slop: 0.05, density: 0.25,
                     collisionFilter: { category: ballCategory, mask: defaultCategory },
                     render: { fillStyle: isHopperBall ? USED_BALL_COLOR : ACTIVE_BALL_COLOR, strokeStyle: '#555', lineWidth: 0.5 }
                 });
                 ball.isReturning = false; ball.isHopper = isHopperBall; ball.isMovingHorizontally = false;
                 ball.pausedVelocity = null; ball.pausedAngularVelocity = null;
                 return ball;
            }

             function createPolygonRow(yPos) {
                const newPolygons = [];
                const offset = (rowCount % 2 === 1) ? POLYGON_SPACING / 2 : 0;
                const maxPolys = Math.floor((PLAY_AREA_WIDTH - 40) / POLYGON_SPACING) + 1;
                let diamondCount = 0;
                const currentObjectCount = hopperBalls.length + activeBalls.length + returningBalls.length + polygons.length;

                for (let i = 0; i < maxPolys; i++) {
                    const x = PLAY_AREA_LEFT + 20 + offset + (i * POLYGON_SPACING);
                    if (x + POLYGON_RADIUS > PLAY_AREA_RIGHT - 10 || currentObjectCount + newPolygons.length >= MAX_OBJECTS) break;
                    let isDiamond = Math.random() < 0.2 && diamondCount < 2; if (isDiamond) diamondCount++;
                    const shapeType = isDiamond ? 4 : Math.floor(Math.random() * 5);
                    const sides = shapeType === 0 ? 32 : shapeType + 2;
                    const value = isDiamond ? 0 : Math.max(1, (Math.floor(Math.random() * 3) + 1) + (rowCount * 3));
                    const color = isDiamond ? DIAMOND_COLOR : colors[Math.floor(Math.random() * colors.length)];
                    const poly = Bodies.polygon(x, yPos, sides, POLYGON_RADIUS, {
                        isStatic: true, value: value, originalValue: value, isDiamond: isDiamond,
                        restitution: 0.9, friction: 0.01,
                        collisionFilter: { category: defaultCategory, mask: ballCategory | defaultCategory },
                        render: { fillStyle: color, strokeStyle: isDiamond ? `rgba(255, 0, 0, ${fadeAlpha})` : '#444', lineWidth: isDiamond ? 2 : 1, textValue: value.toString(), textSize: 12, textColor: '#ffffff', textFont: 'Arial' }
                    });
                    newPolygons.push(poly);
                }
                polygons.push(...newPolygons);
                World.add(world, newPolygons);
                rowCount++;
             }

            function setupInitialBalls(count) {
                if (hopperBalls.length > 0) { World.remove(world, hopperBalls); hopperBalls = []; }
                for (let i = 0; i < count; i++) {
                     const ball = createBallBody(
                         HOPPER_CENTER_X + (Math.random() - 0.5) * HOPPER_TARGET_X_OFFSET * 2,
                         HOPPER_Y + BALL_RADIUS + (Math.random() - 0.5) * HOPPER_TARGET_Y_OFFSET, true );
                     Matter.Body.setStatic(ball, true);
                     World.add(world, ball);
                     hopperBalls.push(ball);
                }
                nextRoundBallCount = count;
                currentLaunchCount = 0;
            }

            setupInitialBalls(1);
            createPolygonRow(CANVAS_HEIGHT - ROW_HEIGHT);
            updateBanner();

            Events.on(engine, 'collisionStart', function(event) {
                if (gameOver || isPausing) return;
                const pairs = event.pairs;
                pairs.forEach(pair => {
                    let ball = null, other = null;
                    if (activeBalls.includes(pair.bodyA)) { ball = pair.bodyA; other = pair.bodyB; }
                    else if (activeBalls.includes(pair.bodyB)) { ball = pair.bodyB; other = pair.bodyA; }

                    if (ball && !ball.isReturning && !ball.isHopper) {
                        if (polygons.includes(other)) {
                            handlePolygonHit(ball, other);
                        } else if (other.isSensor && other.label === 'bottomSensor') {
                            if (!ballsPendingReturnSetup.find(b => b.id === ball.id) && !ball.isReturning) {
                                ballsPendingReturnSetup.push(ball);
                            }
                        }
                    }
                });
            });

             function handlePolygonHit(ball, poly) {
                  if (poly.isDiamond) {
                     nextRoundBallCount++;
                     updateBanner();
                     World.remove(world, poly);
                     polygons = polygons.filter(p => p !== poly);
                 } else {
                     score++;
                     poly.value = Math.max(0, Math.floor(poly.value - 1));
                     if (poly.render) { poly.render.textValue = poly.value.toString(); }
                     updateBanner();
                     if (poly.value <= 0) {
                         World.remove(world, poly);
                         polygons = polygons.filter(p => p !== poly);
                     }
                 }
             }

            function checkEndTurnCondition() {
                if (gameOver || isPausing || !turnInProgress || endTurnPending) {
                    return;
                }
                if (activeBalls.length === 0 && returningBalls.length === 0) {
                    endTurnPending = true;
                    setTimeout(() => {
                        if (!gameOver && !isPausing && turnInProgress && activeBalls.length === 0 && returningBalls.length === 0) {
                            endTurn();
                        } else {
                            endTurnPending = false;
                        }
                    }, 400);
                }
            }

            function triggerGameOver(reason = "Game Over") {
                if (gameOver) return;
                gameOver = true;
                aiming = false; isPausing = false; turnInProgress = false; endTurnPending = false;
                launchInProgressFlag = false; // Reset flag
                pauseResumeGraceTicks = 0;
                isSpedUp = false; engine.timing.timeScale = 1;
                console.log("Game over triggered:", reason, "- Final Score:", score);
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
                document.getElementById('scoreDisplay').style.display = 'block';
                if (scoreFlashInterval) clearInterval(scoreFlashInterval);
                let flashVisible = true;
                scoreFlashInterval = setInterval(() => {
                    if (!gameOver) { clearInterval(scoreFlashInterval); document.getElementById('scoreDisplay').style.visibility = 'visible'; return; }
                    flashVisible = !flashVisible;
                    document.getElementById('scoreDisplay').style.visibility = flashVisible ? 'visible' : 'hidden';
                }, 600);
                document.getElementById('gameOver').innerHTML = 'GAME OVER<br><span style="font-size: 20px;">Right-click or press R to restart</span>';
             }

            Events.on(engine, 'beforeUpdate', function() {
                if (gameOver) return;
                if (pauseResumeGraceTicks > 0) pauseResumeGraceTicks--;

                if (isPausing) {
                     fadeAlpha = fadeAlpha + fadeDirection * 0.02; if (fadeAlpha <= 0 || fadeAlpha >= 1) fadeDirection *= -1; fadeAlpha = Math.max(0, Math.min(1, fadeAlpha));
                     polygons.forEach(poly => {
                         if (poly.isDiamond) poly.render.strokeStyle = `rgba(255, 0, 0, ${fadeAlpha})`;
                         if (poly.position.y - POLYGON_RADIUS < CAGE_Y_POSITION) return triggerGameOver(`Polygon reached cage line during pause`);
                     });
                     return;
                }

                if (ballsPendingReturnSetup.length > 0) {
                    const ballsToProcessNow = [...ballsPendingReturnSetup];
                    ballsPendingReturnSetup = [];
                    ballsToProcessNow.forEach(ballToReturn => {
                        const ballIndex = activeBalls.findIndex(b => b.id === ballToReturn.id);
                        if (!isPausing && !gameOver && ballIndex !== -1 && !ballToReturn.isReturning) {
                            ballToReturn.isReturning = true; ballToReturn.isMovingHorizontally = false;
                            const exitingBall = activeBalls.splice(ballIndex, 1)[0];
                            World.remove(world, exitingBall);
                            const pathway = nextReturnPathway;
                            const entryX = (pathway === 'left') ? PATHWAY_WIDTH / 2 : PLAY_AREA_RIGHT + PATHWAY_WIDTH / 2;
                            const targetY = HOPPER_Y + BALL_RADIUS + (Math.random() - 0.5) * HOPPER_TARGET_Y_OFFSET;
                            const targetX = HOPPER_CENTER_X + (Math.random() - 0.5) * HOPPER_TARGET_X_OFFSET;
                            returningBalls.push({
                                body: exitingBall, x: entryX, y: CANVAS_HEIGHT - BALL_RADIUS,
                                targetX: targetX, targetY: targetY, pathway: pathway,
                                radius: BALL_RADIUS, color: ACTIVE_BALL_COLOR, isMovingHorizontally: false
                            });
                            nextReturnPathway = (pathway === 'left') ? 'right' : 'left';
                            checkEndTurnCondition();
                        }});
                }

                const currentTimescale = engine.timing.timeScale;
                for (let i = returningBalls.length - 1; i >= 0; i--) {
                    const rBall = returningBalls[i]; let arrived = false;
                    if (!rBall.isMovingHorizontally) {
                        rBall.y -= RETURN_BALL_SPEED_VERTICAL * currentTimescale;
                        if (rBall.y <= HORIZONTAL_TRANSITION_Y) { rBall.y = HORIZONTAL_TRANSITION_Y; rBall.isMovingHorizontally = true; }
                    } else {
                        const xDirection = Math.sign(rBall.targetX - rBall.x);
                        rBall.x += xDirection * RETURN_BALL_SPEED_HORIZONTAL * currentTimescale;
                        if ((xDirection > 0 && rBall.x >= rBall.targetX) || (xDirection < 0 && rBall.x <= rBall.targetX) || xDirection === 0) {
                           rBall.x = rBall.targetX; rBall.y += RETURN_BALL_SPEED_VERTICAL * 0.5 * currentTimescale;
                           if (rBall.y >= rBall.targetY) { rBall.y = rBall.targetY; arrived = true; }
                        }}
                    const totalTravelEst = (CANVAS_HEIGHT - HORIZONTAL_TRANSITION_Y) + Math.abs(rBall.targetX - ((rBall.pathway === 'left') ? PATHWAY_WIDTH / 2 : PLAY_AREA_RIGHT + PATHWAY_WIDTH / 2));
                    const currentTravelEst = (CANVAS_HEIGHT - rBall.y) + (rBall.isMovingHorizontally ? Math.abs(rBall.x - ((rBall.pathway === 'left') ? PATHWAY_WIDTH / 2 : PLAY_AREA_RIGHT + PATHWAY_WIDTH / 2)) : 0);
                    rBall.color = interpolateHexColor(ACTIVE_BALL_COLOR, USED_BALL_COLOR, Math.min(1, Math.max(0, currentTravelEst / totalTravelEst)));
                    if (arrived) {
                        const returnedBallBody = rBall.body; returningBalls.splice(i, 1);
                        returnedBallBody.isReturning = false; returnedBallBody.isHopper = true; returnedBallBody.isMovingHorizontally = false;
                        returnedBallBody.render.fillStyle = USED_BALL_COLOR;
                        delete returnedBallBody.pausedVelocity; delete returnedBallBody.pausedAngularVelocity;
                        World.add(world, returnedBallBody); Matter.Body.setStatic(returnedBallBody, true);
                        Matter.Body.setVelocity(returnedBallBody, { x: 0, y: 0 }); Matter.Body.setAngularVelocity(returnedBallBody, 0);
                        Matter.Body.setPosition(returnedBallBody, { x: rBall.x, y: rBall.y });
                        hopperBalls.push(returnedBallBody); checkEndTurnCondition();
                    }}

                try {
                    fadeAlpha = fadeAlpha + fadeDirection * 0.02; if (fadeAlpha <= 0 || fadeAlpha >= 1) fadeDirection *= -1; fadeAlpha = Math.max(0, Math.min(1, fadeAlpha));
                    for (let i = polygons.length - 1; i >= 0; i--) {
                        const poly = polygons[i]; if (!poly) continue;
                        if (poly.isDiamond && poly.render) poly.render.strokeStyle = `rgba(255, 0, 0, ${fadeAlpha})`;
                        if (poly.position.y - POLYGON_RADIUS < CAGE_Y_POSITION) return triggerGameOver(`Polygon reached cage line`);
                        if (poly.value <= 0 && !poly.isDiamond) {
                             if (World.get(world, poly.id, 'body')) World.remove(world, poly); polygons.splice(i, 1);
                        } else if (!poly.isDiamond && poly.render) { poly.render.textValue = Math.floor(poly.value).toString(); }
                    }
                    if (polygons.length > MAX_OBJECTS * 0.85) {
                         const excess = polygons.length - Math.floor(MAX_OBJECTS * 0.85); const removedPolys = polygons.splice(0, excess); World.remove(world, removedPolys); }

                    for (let i = activeBalls.length - 1; i >= 0; i--) {
                        const ball = activeBalls[i]; if (!ball) continue;
                        if (!ball.isStatic && !ball.isReturning && !ball.isHopper) {
                            const MAX_SPEED = 15; const MAX_SPEED_SQ = MAX_SPEED * MAX_SPEED;
                            if (Vector.magnitudeSquared(ball.velocity) > MAX_SPEED_SQ) { Matter.Body.setVelocity(ball, Vector.mult(Vector.normalise(ball.velocity), MAX_SPEED)); }
                            if (ball.render.fillStyle !== ACTIVE_BALL_COLOR) ball.render.fillStyle = ACTIVE_BALL_COLOR;
                            if (pauseResumeGraceTicks <= 0 && ball.speed < STUCK_SPEED_THRESHOLD && ball.position.y < STUCK_ESCAPE_ZONE_Y) {
                                const kickVx = (Math.random() - 0.5) * STUCK_KICK_VX_AMP; const kickVy = STUCK_KICK_VY_MIN - (Math.random() * STUCK_KICK_VY_RAND);
                                Matter.Body.setVelocity(ball, Vector.add(ball.velocity, { x: kickVx, y: kickVy })); }
                            const wallRestitution = 0.9;
                            if (ball.position.x < PLAY_AREA_LEFT + BALL_RADIUS) { Matter.Body.setPosition(ball, { x: PLAY_AREA_LEFT + BALL_RADIUS + 0.1, y: ball.position.y }); Matter.Body.setVelocity(ball, { x: Math.abs(ball.velocity.x) * wallRestitution, y: ball.velocity.y }); }
                            else if (ball.position.x > PLAY_AREA_RIGHT - BALL_RADIUS) { Matter.Body.setPosition(ball, { x: PLAY_AREA_RIGHT - BALL_RADIUS - 0.1, y: ball.position.y }); Matter.Body.setVelocity(ball, { x: -Math.abs(ball.velocity.x) * wallRestitution, y: ball.velocity.y }); }
                            if (ball.position.y > CANVAS_HEIGHT + 50) {
                                if (!ball.isReturning) {
                                    ball.isReturning = true; ball.isMovingHorizontally = false; World.remove(world, ball); activeBalls.splice(i, 1);
                                    const pathway = nextReturnPathway; const entryX = (pathway === 'left') ? PATHWAY_WIDTH / 2 : PLAY_AREA_RIGHT + PATHWAY_WIDTH / 2;
                                    const targetY = HOPPER_Y + BALL_RADIUS + (Math.random() - 0.5) * HOPPER_TARGET_Y_OFFSET; const targetX = HOPPER_CENTER_X + (Math.random() - 0.5) * HOPPER_TARGET_X_OFFSET;
                                    returningBalls.push({ body: ball, x: entryX, y: CANVAS_HEIGHT - BALL_RADIUS, targetX: targetX, targetY: targetY, pathway: pathway, radius: BALL_RADIUS, color: ACTIVE_BALL_COLOR, isMovingHorizontally: false });
                                    nextReturnPathway = (pathway === 'left') ? 'right' : 'left'; checkEndTurnCondition(); continue;
                                }}
                        }}
                    if (turnInProgress && activeBalls.length === 0 && returningBalls.length === 0 && !isPausing) { checkEndTurnCondition(); }
                } catch (error) { console.error("Update loop error:", error); triggerGameOver("Update loop error"); }
            });

            let mousePos = { x: 0, y: 0 };
            render.canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    if (gameOver) return;
                    mousePos = { x: e.offsetX, y: e.offsetY };
                    if (turnInProgress && activeBalls.length > 0) {
                        if (launchInProgressFlag) { // Check flag
                            console.log("Launch in progress, mousedown ignored for pausing.");
                            return;
                        }
                        if (!isPausing) {
                            isPausing = true; aiming = false; pauseResumeGraceTicks = 0;
                            activeBalls.forEach(ball => {
                                if (!ball.isStatic && !ball.isReturning && !ball.isHopper) {
                                    ball.pausedVelocity = Vector.clone(ball.velocity); ball.pausedAngularVelocity = ball.angularVelocity;
                                    Matter.Body.setStatic(ball, true);
                                }});
                        }
                    } else if (!aiming && !turnInProgress && hopperBalls.length > 0) {
                        aiming = true; isPausing = false;
                    }
                } else if (e.button === 2) {
                    e.preventDefault();
                    if (gameOver) { restartGame(); }
                    else {
                        const currentTime = Date.now();
                        if (currentTime - lastRightClickTime < DOUBLE_CLICK_THRESHOLD) {
                            if (!isPausing) { isSpedUp = !isSpedUp; engine.timing.timeScale = isSpedUp ? 3 : 1; }
                            lastRightClickTime = 0;
                        } else { lastRightClickTime = currentTime; }
                    }}
             });
            render.canvas.addEventListener('mousemove', (e) => { if ((aiming || isPausing) && !gameOver) { mousePos = { x: e.offsetX, y: e.offsetY }; } });
            render.canvas.addEventListener('mouseup', (e) => {
                if (gameOver || e.button !== 0) return;
                const endPos = { x: e.offsetX, y: e.offsetY };
                if (isPausing) { // Resume from Pause
                    isPausing = false; const direction = Vector.sub(endPos, startPos); let newLaunchVelocity = null; let reAimIsValid = false;
                    if (direction.y > 5 && Vector.magnitudeSquared(direction) > 20 * 20) {
                        const angle = Math.atan2(direction.y, direction.x);
                        if (!(angle > -Math.PI*0.98 && angle < -Math.PI*0.02) && !(angle < Math.PI*0.02 && angle > -Math.PI*0.02)) {
                            newLaunchVelocity = Vector.mult(Vector.normalise(direction), LAUNCH_MAGNITUDE); reAimIsValid = true; launchDirection = Vector.clone(newLaunchVelocity);
                        }}
                    activeBalls.forEach((ball) => {
                        if (ball.isStatic && !ball.isReturning && !ball.isHopper && ball.pausedVelocity) {
                             Matter.Body.setStatic(ball, false);
                             if (reAimIsValid && newLaunchVelocity) { Matter.Body.setVelocity(ball, newLaunchVelocity); }
                             else { Matter.Body.setVelocity(ball, ball.pausedVelocity); Matter.Body.setAngularVelocity(ball, ball.pausedAngularVelocity || 0); }
                             delete ball.pausedVelocity; delete ball.pausedAngularVelocity;
                        } else if (ball.isStatic && !ball.isReturning && !ball.isHopper) { Matter.Body.setStatic(ball, false); }
                    });
                    pauseResumeGraceTicks = PAUSE_RESUME_GRACE_TICKS_TOTAL;
                } else if (aiming) { // Execute Initial Launch
                    aiming = false; const direction = Vector.sub(endPos, startPos);
                    if (direction.y > 5 && Vector.magnitudeSquared(direction) > 40 * 40) {
                         const angle = Math.atan2(direction.y, direction.x);
                         if (!(angle > -Math.PI*0.98 && angle < -Math.PI*0.02) && !(angle < Math.PI*0.02 && angle > -Math.PI*0.02)) {
                            turnInProgress = true; launchInProgressFlag = true; // Set flag
                            pauseResumeGraceTicks = 0; endTurnPending = false;
                            launchDirection = Vector.mult(Vector.normalise(direction), LAUNCH_MAGNITUDE);
                            const countToLaunch = Math.min(hopperBalls.length, nextRoundBallCount);
                            if (countToLaunch === 0) {
                                console.error("Launch Error: No balls available to launch (countToLaunch is 0).");
                                turnInProgress = false; launchInProgressFlag = false; return;
                            }
                            currentLaunchCount = countToLaunch;
                            console.log(`Attempting to launch ${currentLaunchCount} balls. Hopper before: ${hopperBalls.length}, NextRound: ${nextRoundBallCount}`);
                            const ballsToLaunch = hopperBalls.splice(0, currentLaunchCount);
                            console.log(`Spliced ${ballsToLaunch.length} balls. Hopper after: ${hopperBalls.length}. activeBalls before adding: ${activeBalls.length}`);

                            ballsToLaunch.forEach((ball, index) => {
                                ball.isHopper = false; ball.isReturning = false; ball.isMovingHorizontally = false; ball.render.fillStyle = ACTIVE_BALL_COLOR;
                                delete ball.pausedVelocity; delete ball.pausedAngularVelocity; activeBalls.push(ball);
                                setTimeout(() => {
                                    if (!gameOver && !isPausing) {
                                        Matter.Body.setStatic(ball, false); Matter.Body.setPosition(ball, startPos);
                                        Matter.Body.setVelocity(ball, launchDirection); Matter.Body.setAngularVelocity(ball, (Math.random() - 0.5) * 0.05);
                                    } else {
                                        console.warn(`Launch for ball ${ball.id} aborted (gameOver=${gameOver}, isPausing=${isPausing}). Returning to hopper.`);
                                        if (activeBalls.includes(ball)) activeBalls.splice(activeBalls.indexOf(ball), 1);
                                        if (!hopperBalls.includes(ball)) hopperBalls.unshift(ball);
                                        Matter.Body.setStatic(ball, true); ball.render.fillStyle = USED_BALL_COLOR; ball.isHopper = true;
                                        Matter.Body.setPosition(ball, { x: HOPPER_CENTER_X + (Math.random()-0.5)*HOPPER_TARGET_X_OFFSET, y: HOPPER_Y + BALL_RADIUS + (Math.random()-0.5)*HOPPER_TARGET_Y_OFFSET });
                                    }}, index * LAUNCH_STAGGER_MS);
                            });
                            console.log(`All ${currentLaunchCount} balls scheduled for launch. activeBalls.length now: ${activeBalls.length}`);
                            // Schedule the flag to be reset
                            const totalLaunchTime = (ballsToLaunch.length > 0 ? (ballsToLaunch.length - 1) * LAUNCH_STAGGER_MS : 0) + (LAUNCH_STAGGER_MS * 2); // Time for last ball to fire + buffer
                            setTimeout(() => {
                                launchInProgressFlag = false;
                                console.log("Launch sequence flag reset.");
                                // Check if turn should end if all launches failed and balls returned
                                if (turnInProgress && activeBalls.length === 0 && returningBalls.length === 0 && !isPausing) {
                                    checkEndTurnCondition();
                                }
                            }, totalLaunchTime);
                        } else { turnInProgress = false; launchInProgressFlag = false; console.log("Initial launch cancelled - invalid angle."); }
                    } else { turnInProgress = false; launchInProgressFlag = false; console.log("Initial launch cancelled - drag invalid."); }
                }
            });
            render.canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); });

            Events.on(render, 'afterRender', function() {
                 const context = render.context; context.save(); context.globalCompositeOperation = 'source-over';
                 polygons.forEach(poly => {
                     if (poly.render && poly.render.textValue && !poly.isDiamond) {
                         context.font = `${poly.render.textSize || 12}px ${poly.render.textFont || 'Arial'}`; context.textAlign = 'center'; context.textBaseline = 'middle';
                         context.strokeStyle = 'rgba(0,0,0,0.7)'; context.lineWidth = 2; context.strokeText(poly.render.textValue, poly.position.x, poly.position.y);
                         context.fillStyle = poly.render.textColor || '#ffffff'; context.fillText(poly.render.textValue, poly.position.x, poly.position.y);
                     }});
                 returningBalls.forEach(rBall => {
                     context.beginPath(); context.arc(rBall.x, rBall.y, rBall.radius, 0, Math.PI * 2); context.fillStyle = rBall.color; context.fill();
                     context.strokeStyle = '#555'; context.lineWidth = 0.5; context.stroke(); });
                 if (!gameOver) {
                     context.beginPath(); context.strokeStyle = '#CC0000'; context.lineWidth = CAGE_LINE_WIDTH; context.setLineDash([]);
                     const leftLineEndX = HOPPER_CENTER_X - CAGE_GAP_WIDTH / 2; const rightLineStartX = HOPPER_CENTER_X + CAGE_GAP_WIDTH / 2;
                     context.moveTo(PLAY_AREA_LEFT, CAGE_Y_POSITION); context.lineTo(leftLineEndX, CAGE_Y_POSITION);
                     context.moveTo(rightLineStartX, CAGE_Y_POSITION); context.lineTo(PLAY_AREA_RIGHT, CAGE_Y_POSITION); context.stroke(); }
                 if ((aiming || isPausing) && !gameOver) {
                     context.beginPath(); context.strokeStyle = '#000000'; context.lineWidth = 2; context.setLineDash([10, 5]);
                     const dx = mousePos.x - startPos.x; const dy = mousePos.y - startPos.y;
                     if (dy > 5) {
                         const angle = Math.atan2(dy, dx);
                         if (!(angle > -Math.PI*0.98 && angle < -Math.PI*0.02) && !(angle < Math.PI*0.02 && angle > -Math.PI*0.02)) {
                             const length = Math.min(Vector.magnitude({x: dx, y: dy}), 250);
                             context.moveTo(startPos.x, startPos.y); context.lineTo(startPos.x + Math.cos(angle) * length, startPos.y + Math.sin(angle) * length); context.stroke();
                         }} context.setLineDash([]); }
                 context.restore();
              });

             function restartGame() {
                 if (scoreFlashInterval) clearInterval(scoreFlashInterval); scoreFlashInterval = null;
                 World.clear(world); Engine.clear(engine);
                 engine.gravity.y = 1.0; engine.timing.timeScale = 1; engine.positionIterations = 12; engine.velocityIterations = 12; isSpedUp = false;
                 score = 0; activeBalls = []; returningBalls = []; hopperBalls = []; polygons = [];
                 gameOver = false; aiming = false; isPausing = false; turnInProgress = false; endTurnPending = false;
                 launchInProgressFlag = false; // Reset flag
                 pauseResumeGraceTicks = 0; currentLaunchCount = 0; nextRoundBallCount = 1; round = 1; rowCount = 0;
                 launchDirection = null; startPos = { x: FIXED_START_X, y: LAUNCH_POINT_Y }; lastRightClickTime = 0; nextReturnPathway = 'left';
                 ballsPendingReturnSetup = [];

                 document.getElementById('gameOver').style.display = 'none'; document.getElementById('scoreDisplay').style.display = 'none';
                 document.getElementById('scoreDisplay').style.visibility = 'visible'; document.getElementById('gameOver').innerHTML = 'GAME OVER';
                 World.add(world, [
                    Bodies.rectangle(PLAY_AREA_LEFT + 2, CANVAS_HEIGHT/2 + TOP_UI_HEIGHT/2, 4, CANVAS_HEIGHT, {isStatic:true, collisionFilter:{category:defaultCategory, mask:ballCategory}, render:{visible:false}}),
                    Bodies.rectangle(PLAY_AREA_RIGHT - 2, CANVAS_HEIGHT/2 + TOP_UI_HEIGHT/2, 4, CANVAS_HEIGHT, {isStatic:true, collisionFilter:{category:defaultCategory, mask:ballCategory}, render:{visible:false}}),
                    Bodies.rectangle(HOPPER_CENTER_X, CANVAS_HEIGHT + 30, PLAY_AREA_WIDTH, 60, {isStatic:true, isSensor:true, label:'bottomSensor', collisionFilter:{category:defaultCategory, mask:ballCategory}, render:{visible:false}})]);
                 setupInitialBalls(1); createPolygonRow(CANVAS_HEIGHT - ROW_HEIGHT); updateBanner();
            }
             window.addEventListener('keydown', (e) => { if (!e.repeat && (e.key === 'r' || e.key === 'R')) { if (gameOver) restartGame(); } });

            function endTurn() {
                if (gameOver || isPausing) { endTurnPending = false; return; }
                turnInProgress = false; endTurnPending = false; launchInProgressFlag = false; // Reset flag

                pauseResumeGraceTicks = 0; if (engine.timing.timeScale !== 1) { engine.timing.timeScale = 1; isSpedUp = false; }
                if (activeBalls.length > 0) { World.remove(world, activeBalls); activeBalls = []; }
                if (returningBalls.length > 0) { returningBalls = []; }
                if (nextRoundBallCount <= 0) nextRoundBallCount = 1;
                const excess = hopperBalls.length - nextRoundBallCount;
                if (excess > 0) { const ballsToRemove = hopperBalls.splice(0, excess); World.remove(world, ballsToRemove); }
                else if (hopperBalls.length < nextRoundBallCount) {
                     const needed = nextRoundBallCount - hopperBalls.length;
                     for (let i = 0; i < needed; i++) {
                         const newBall = createBallBody(HOPPER_CENTER_X + (Math.random()-0.5)*HOPPER_TARGET_X_OFFSET*2, HOPPER_Y + BALL_RADIUS + (Math.random()-0.5)*HOPPER_TARGET_Y_OFFSET, true );
                         Matter.Body.setStatic(newBall, true); World.add(world, newBall); hopperBalls.push(newBall);
                     }}
                 hopperBalls.forEach(ball => {
                    if (!ball.isStatic) Matter.Body.setStatic(ball, true); if (!ball.isHopper) ball.isHopper = true;
                    ball.render.fillStyle = USED_BALL_COLOR;
                    Matter.Body.setPosition(ball, { x: ball.position.x + (Math.random()-0.5)*0.1, y: ball.position.y + (Math.random()-0.5)*0.1 });
                    Matter.Body.setVelocity(ball, {x:0,y:0}); Matter.Body.setAngularVelocity(ball, 0); });
                let triggeredGameOver = false;
                polygons.forEach(poly => {
                     Matter.Body.translate(poly, { x: 0, y: -ROW_HEIGHT });
                     if (!triggeredGameOver && poly.position.y - POLYGON_RADIUS < CAGE_Y_POSITION) {
                         triggeredGameOver = true; setTimeout(() => triggerGameOver(`Polygon reached cage line after move`), 50);
                     }});
                if (triggeredGameOver) return;
                const availableSpaceForPolys = MAX_OBJECTS - hopperBalls.length - polygons.length;
                const polysInRowEstimate = Math.floor((PLAY_AREA_WIDTH - 40) / POLYGON_SPACING) + 1;
                if (availableSpaceForPolys >= polysInRowEstimate) { createPolygonRow(CANVAS_HEIGHT - ROW_HEIGHT); }
                round++; aiming = false; isPausing = false; launchDirection = null; currentLaunchCount = 0;
                updateBanner();
            }

            Engine.run(engine); Render.run(render);
        } catch (error) {
            console.error('Game failed to initialize:', error);
            document.body.innerHTML += `<p style="color: red; position: absolute; top: 100px; left: 10px; background: white; padding: 10px; border: 1px solid black;">Error loading game: ${error.message}. Check console.</p>`;
        }
    </script>
</body>
</html>