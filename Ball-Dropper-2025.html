<!DOCTYPE html>
<html>
<head>
    <title>Polygon Ball Dropper</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #e0e0e0; }
        #gameContainer { position: relative; width: 356px; height: 760px; overflow: hidden; }
        canvas { border: 1px solid black; background: #f0f0f0; position: absolute; top: 60px; left: 0; cursor: crosshair; }
        #marqueeBanner { position: absolute; top: 0; left: 0; width: 100%; height: 30px; background: #0066cc; color: white; font-family: Arial, sans-serif; font-size: 20px; text-align: center; line-height: 30px; z-index: 11; }
        #banner { position: absolute; top: 30px; left: 0; width: 100%; height: 30px; background: #333; color: white; font-family: Arial, sans-serif; font-size: 20px; text-align: center; line-height: 30px; z-index: 10; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Arial Black', Gadget, sans-serif; font-size: 50px; font-weight: bold; color: #CC0000; display: none; text-align: center; text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.6); z-index: 100; width: 90%; }
        #scoreDisplay { position: absolute; top: 65%; left: 50%; transform: translate(-50%, -50%); font-family: Arial, sans-serif; font-size: 26px; font-weight: bold; color: #CC0000; display: none; text-align: center; text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5); z-index: 100; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="marqueeBanner">Tracy's Ball Droppers</div>
        <div id="banner">Score: 0 | Balls: 1 | Round: 1</div>
        <div id="gameOver">GAME OVER</div>
        <div id="scoreDisplay">Score: 0</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        try {
            const Engine = Matter.Engine, Render = Matter.Render, World = Matter.World, Bodies = Matter.Bodies, Events = Matter.Events, Vector = Matter.Vector;

            const engine = Engine.create({ timing: { timeScale: 1 }, positionIterations: 10, velocityIterations: 10 });
            const world = engine.world;
            engine.gravity.y = 1.0;

            const CANVAS_WIDTH = 356, CANVAS_HEIGHT = 720, ROW_HEIGHT = 80, MAX_OBJECTS = 120, POLYGON_SPACING = 32;
            const POLYGON_RADIUS = 20;
            const CAGE_Y_POSITION = 45;
            const CAGE_GAP_WIDTH = 36;
            const CAGE_LINE_WIDTH = 2;
            const FIXED_START_X = CANVAS_WIDTH / 2;
            const LAUNCH_MAGNITUDE = 16; // Consistent launch speed

            const render = Render.create({
                element: document.getElementById('gameContainer'),
                engine: engine,
                options: { width: CANVAS_WIDTH, height: CANVAS_HEIGHT, wireframes: false, background: '#f0f0f0' }
            });
            if (!render.canvas) throw new Error("Canvas failed to create");

            const defaultCategory = 0x0001, ballCategory = 0x0002;

            let score = 0, balls = [], usedBalls = [], polygons = [];
            let gameOver = false, aiming = false, turnInProgress = false;
            let isPausing = false; // Used when pausing mid-turn
            let startPos = { x: FIXED_START_X, y: 20 };
            let aimLine = null, round = 1;
            let currentLaunchCount = 1, nextRoundBallCount = 1;
            let rowCount = 0;
            let launchDirection = null; // Stores the ACTIVE launch direction for the turn (updated on re-aim)
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96c93d', '#ffa502'];
            const DIAMOND_COLOR = '#000000', ACTIVE_BALL_COLOR = '#ff4500', USED_BALL_COLOR = '#808080';
            let fadeAlpha = 0, fadeDirection = 1, scoreFlashInterval = null;

            // Anti-Stuck & Pause Grace Period
            const STUCK_SPEED_THRESHOLD = 0.15;
            const STUCK_ESCAPE_ZONE_Y = CANVAS_HEIGHT - 40;
            const STUCK_KICK_VY_MIN = -0.8;
            const STUCK_KICK_VY_RAND = 1.0;
            const STUCK_KICK_VX_AMP = 0.5;
            let pauseResumeGraceTicks = 0; // Counter for grace period after resuming from pause
            const PAUSE_RESUME_GRACE_TICKS_TOTAL = 5; // How many physics ticks to ignore anti-stuck after resume

            // Speed Up Feature
            let isSpedUp = false;
            let lastRightClickTime = 0;
            const DOUBLE_CLICK_THRESHOLD = 500; // milliseconds

            function updateBanner() {
                document.getElementById('banner').textContent = `Score: ${score} | Balls: ${nextRoundBallCount} | Round: ${round}`;
            }

            // --- World Setup ---
            World.add(world, [
                Bodies.rectangle(3, CANVAS_HEIGHT / 2, 4, CANVAS_HEIGHT, { isStatic: true, restitution: 0.8, friction: 0.0, collisionFilter: { category: defaultCategory, mask: ballCategory } }),
                Bodies.rectangle(351, CANVAS_HEIGHT / 2, 4, CANVAS_HEIGHT, { isStatic: true, restitution: 0.8, friction: 0.0, collisionFilter: { category: defaultCategory, mask: ballCategory } }),
                Bodies.rectangle(CANVAS_WIDTH / 2, CANVAS_HEIGHT + 30, CANVAS_WIDTH, 60, { isStatic: true, isSensor: true, label: 'bottomSensor', collisionFilter: { category: defaultCategory, mask: ballCategory } })
            ]);

            // --- Ball Creation ---
            function createBall(x = FIXED_START_X, y = 20, isUsed = false) {
                if (balls.length + usedBalls.length >= MAX_OBJECTS) return null;
                const ball = Bodies.circle(x, y, 7.5, {
                    restitution: 0.85, friction: 0.001, frictionStatic: 0.01, frictionAir: 0.005,
                    slop: 0.05, density: 0.3,
                    collisionFilter: { category: ballCategory, mask: defaultCategory },
                    render: { fillStyle: isUsed ? USED_BALL_COLOR : ACTIVE_BALL_COLOR }
                });
                ball.isSettled = false; ball.isUsed = isUsed;
                // Add properties for pause/resume velocity storage
                ball.pausedVelocity = null; ball.pausedAngularVelocity = null;
                Matter.Body.setStatic(ball, isUsed);
                if (isUsed) usedBalls.push(ball); else balls.push(ball);
                World.add(world, ball);
                return ball;
            }

            // --- Polygon Creation ---
             function createPolygonRow(yPos) {
                const newPolygons = [];
                const offset = (rowCount % 2 === 1) ? POLYGON_SPACING / 2 : 0;
                const maxPolys = Math.floor((CANVAS_WIDTH - 50) / POLYGON_SPACING) + 1;
                let diamondCount = 0;
                for (let i = 0; i < maxPolys; i++) {
                    const x = 29 + offset + (i * POLYGON_SPACING);
                    if (x + POLYGON_RADIUS > CANVAS_WIDTH - 12 || polygons.length + newPolygons.length >= MAX_OBJECTS) break;
                    let isDiamond = Math.random() < 0.2 && diamondCount < 2; if (isDiamond) diamondCount++;
                    const shapeType = isDiamond ? 4 : Math.floor(Math.random() * 5);
                    const sides = shapeType === 0 ? 32 : shapeType + 2;
                    const value = isDiamond ? 0 : Math.max(1, (Math.floor(Math.random() * 3) + 1) + (rowCount * 3));
                    const color = isDiamond ? DIAMOND_COLOR : colors[Math.floor(Math.random() * colors.length)];
                    const poly = Bodies.polygon(x, yPos, sides, POLYGON_RADIUS, {
                        isStatic: true, value: value, originalValue: value, isDiamond: isDiamond,
                        restitution: 0.8, friction: 0.01, frictionStatic: 0.05, slop: 0.02, density: 1.0,
                        collisionFilter: { category: defaultCategory, mask: ballCategory | defaultCategory },
                        render: {
                            fillStyle: color,
                            strokeStyle: isDiamond ? `rgba(255, 0, 0, ${fadeAlpha})` : null,
                            lineWidth: isDiamond ? 2 : 0,
                            textValue: value.toString(), // Custom property
                            textSize: 12,
                            textColor: '#ffffff',
                            textFont: 'Arial'
                        }
                    });
                    newPolygons.push(poly);
                }
                polygons.push(...newPolygons);
                World.add(world, newPolygons);
                rowCount++;
             }

            // --- Initial Game Setup ---
            createBall(startPos.x, startPos.y, true);
            createPolygonRow(CANVAS_HEIGHT - ROW_HEIGHT);
            updateBanner();

            // --- Collision Handling ---
            Events.on(engine, 'collisionStart', function(event) {
                if (gameOver || isPausing) return; // Ignore collisions during pause
                const pairs = event.pairs;
                pairs.forEach(pair => {
                    let ball = null, other = null;
                    if (balls.includes(pair.bodyA)) { ball = pair.bodyA; other = pair.bodyB; }
                    else if (balls.includes(pair.bodyB)) { ball = pair.bodyB; other = pair.bodyA; }

                    if (ball && !ball.isSettled && !ball.isUsed) {
                        if (polygons.includes(other)) {
                            handlePolygonHit(ball, other);
                        } else if (other.isSensor && other.label === 'bottomSensor') {
                            // Delay slightly to ensure it wasn't just a graze
                            setTimeout(() => { if (!isPausing && !ball.isSettled) settleBall(ball); }, 50);
                        }
                    }
                });
            });

            function handlePolygonHit(ball, poly) {
                 if (poly.isDiamond) {
                    nextRoundBallCount++; updateBanner();
                    World.remove(world, poly); polygons = polygons.filter(p => p !== poly);
                } else {
                    score++;
                    const damage = 1; // Standard damage
                    poly.value = Math.max(0, Math.floor(poly.value - damage));

                    if (poly.render) { poly.render.textValue = poly.value.toString(); } // Update custom text property
                    updateBanner();

                    // Remove polygon immediately if value is zero
                    if (poly.value <= 0) {
                        World.remove(world, poly);
                        polygons = polygons.filter(p => p !== poly);
                    }
                }
            }

            // --- Ball Settlement Logic ---
            function settleBall(ball) {
                 if (!ball || ball.isSettled || ball.isUsed || gameOver || isPausing) return;
                const settlementPosition = { x: FIXED_START_X, y: startPos.y };
                ball.isSettled = true; ball.isUsed = true;
                // Clear any stored pause velocity
                delete ball.pausedVelocity;
                delete ball.pausedAngularVelocity;
                Matter.Body.setStatic(ball, true); Matter.Body.setVelocity(ball, { x: 0, y: 0 }); Matter.Body.setAngularVelocity(ball, 0);
                Matter.Body.setPosition(ball, settlementPosition); ball.render.fillStyle = USED_BALL_COLOR; // Reset color
                usedBalls.push(ball); balls = balls.filter(b => b !== ball);
                if (balls.length === 0 && usedBalls.length >= currentLaunchCount) {
                    // Ensure all visual representations are at the start point
                    usedBalls.forEach(ub => Matter.Body.setPosition(ub, settlementPosition));
                    startPos.x = settlementPosition.x; startPos.y = settlementPosition.y;
                    checkEndTurnCondition();
                }
            }

             // --- Check End Turn Condition ---
             function checkEndTurnCondition() {
                 if (!gameOver && !isPausing && turnInProgress && balls.length === 0 && usedBalls.length >= currentLaunchCount) {
                    turnInProgress = false; aiming = false; isPausing = false;
                    // Short delay to allow last ball settling visually before turn ends
                    setTimeout(() => {
                        if (!gameOver && !isPausing && balls.length === 0 && usedBalls.length >= currentLaunchCount) {
                             endTurn();
                        }
                    }, 300);
                 }
             }

            // --- Game Over Logic ---
            function triggerGameOver(reason = "Game Over") {
                if (gameOver) return;
                gameOver = true; aiming = false; isPausing = false; turnInProgress = false;
                pauseResumeGraceTicks = 0; // Reset grace period on game over
                isSpedUp = false; // Reset speed up state
                engine.timing.timeScale = 1; // Ensure time scale is normal
                console.log("Game over triggered:", reason, "- Final Score:", score);
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
                document.getElementById('scoreDisplay').style.display = 'block';
                if (aimLine) { World.remove(world, aimLine); aimLine = null; }
                if (scoreFlashInterval) clearInterval(scoreFlashInterval);
                let flashVisible = true;
                scoreFlashInterval = setInterval(() => {
                    if (!gameOver) { clearInterval(scoreFlashInterval); document.getElementById('scoreDisplay').style.visibility = 'visible'; return; }
                    flashVisible = !flashVisible; document.getElementById('scoreDisplay').style.visibility = flashVisible ? 'visible' : 'hidden';
                }, 600);
                // Add message for restart option
                document.getElementById('gameOver').innerHTML = 'GAME OVER<br><span style="font-size: 20px;">Right-click to restart</span>';
             }

            // --- Main Game Loop (Before Update) ---
            Events.on(engine, 'beforeUpdate', function() {
                if (gameOver) return;

                // Decrement pause resume grace ticks if active
                if (pauseResumeGraceTicks > 0) {
                    pauseResumeGraceTicks--;
                }

                // --- Pause Logic ---
                if (isPausing) {
                     // Update visual elements that should continue during pause (like diamond flicker)
                     fadeAlpha = fadeAlpha + fadeDirection * 0.02; if (fadeAlpha <= 0 || fadeAlpha >= 1) fadeDirection *= -1; fadeAlpha = Math.max(0, Math.min(1, fadeAlpha));
                     polygons.forEach(poly => {
                         if (poly.isDiamond) poly.render.strokeStyle = `rgba(255, 0, 0, ${fadeAlpha})`;
                         // Check for game over condition even during pause (e.g., if something shifted unexpectedly)
                         if (poly.position.y - POLYGON_RADIUS < CAGE_Y_POSITION) return triggerGameOver(`Polygon reached cage line during pause`);
                     });
                     // Skip the rest of the physics/game logic update
                     return;
                }

                // --- Normal Update Logic ---
                try {
                    // Update diamond flicker alpha
                    fadeAlpha = fadeAlpha + fadeDirection * 0.02; if (fadeAlpha <= 0 || fadeAlpha >= 1) fadeDirection *= -1; fadeAlpha = Math.max(0, Math.min(1, fadeAlpha));

                    // Polygon checks and updates
                    for (let i = polygons.length - 1; i >= 0; i--) {
                        const poly = polygons[i];
                        if (!poly) continue; // Safety check

                        // Apply flicker effect
                        if (poly.isDiamond && poly.render) poly.render.strokeStyle = `rgba(255, 0, 0, ${fadeAlpha})`;

                        // Check game over condition
                        if (poly.position.y - POLYGON_RADIUS < CAGE_Y_POSITION) return triggerGameOver(`Polygon reached cage line`);

                        // Remove destroyed polygons (already handled in collision, but double-check)
                        if (poly.value <= 0 && !poly.isDiamond) {
                            if (World.get(world, poly.id, 'body')) { // Check if it still exists in world
                                World.remove(world, poly);
                            }
                            polygons.splice(i, 1); // Remove from our tracking array
                        }
                        // Update text value render property
                        else if (!poly.isDiamond && poly.render) {
                            poly.render.textValue = Math.floor(poly.value).toString();
                        }
                    }
                    // Polygon Culling (if needed, though MAX_OBJECTS should handle it)
                    if (polygons.length > MAX_OBJECTS * 0.85) { const excess = polygons.length - Math.floor(MAX_OBJECTS * 0.85); const removedPolys = polygons.splice(0, excess); World.remove(world, removedPolys); }

                    // Ball physics, anti-stuck, and color logic
                    balls.forEach(ball => {
                        if (!ball.isStatic && !ball.isSettled && !ball.isUsed) {
                            // Speed cap
                            const MAX_SPEED = 15; const MAX_SPEED_SQ = MAX_SPEED * MAX_SPEED;
                            if (Vector.magnitudeSquared(ball.velocity) > MAX_SPEED_SQ) Matter.Body.setVelocity(ball, Vector.mult(Vector.normalise(ball.velocity), MAX_SPEED));

                            // Ensure balls have the standard active color
                            if (ball.render.fillStyle !== ACTIVE_BALL_COLOR) {
                                ball.render.fillStyle = ACTIVE_BALL_COLOR;
                            }

                            // --- Anti-Stuck Logic (with Grace Period Check) ---
                            if (pauseResumeGraceTicks <= 0 && ball.speed < STUCK_SPEED_THRESHOLD && ball.position.y < STUCK_ESCAPE_ZONE_Y) {
                                const kickVx = (Math.random() - 0.5) * STUCK_KICK_VX_AMP;
                                const kickVy = STUCK_KICK_VY_MIN - (Math.random() * STUCK_KICK_VY_RAND);
                                Matter.Body.setVelocity(ball, Vector.add(ball.velocity, { x: kickVx, y: kickVy }));
                                // console.log(`Kicking stuck ball ${ball.id}`);
                            }

                            // Wall boundary checks (simple position correction and velocity dampening)
                            if (ball.position.x < 7.5) { Matter.Body.setPosition(ball, { x: 7.5, y: ball.position.y }); Matter.Body.setVelocity(ball, { x: Math.abs(ball.velocity.x) * 0.6, y: ball.velocity.y }); }
                            else if (ball.position.x > CANVAS_WIDTH - 7.5) { Matter.Body.setPosition(ball, { x: CANVAS_WIDTH - 7.5, y: ball.position.y }); Matter.Body.setVelocity(ball, { x: -Math.abs(ball.velocity.x) * 0.6, y: ball.velocity.y }); }
                            // Safety net for balls falling through floor
                            if (ball.position.y > CANVAS_HEIGHT + 50) { console.warn(`Ball ${ball.id} fell through! Forcing settlement.`); settleBall(ball); }
                        }
                    });

                    // Check if turn should end naturally (all balls settled)
                    if (turnInProgress && balls.length === 0 && !isPausing) {
                         checkEndTurnCondition();
                    }

                } catch (error) { console.error("Update loop error:", error); triggerGameOver("Update loop error"); }
            });

            // --- Mouse and Input Handling ---
            let mousePos = { x: 0, y: 0 };

            render.canvas.addEventListener('mousedown', (e) => {
                // --- Left Click Logic (Pause/Aim Start) ---
                if (e.button === 0) {
                    if (gameOver) return; // Ignore left clicks if game over

                    mousePos = { x: e.offsetX, y: e.offsetY };

                    if (turnInProgress && balls.length > 0) { // Start Pause during turn
                        if (!isPausing) { // Only pause if not already pausing
                            isPausing = true; aiming = false; // Set pausing, aiming is false (we are not starting a *new* aim)
                            console.log("Pausing turn: Storing velocities and setting static.");
                            pauseResumeGraceTicks = 0; // Reset grace ticks when starting pause
                            balls.forEach(ball => {
                                if (!ball.isStatic && !ball.isSettled && !ball.isUsed) {
                                    // Store current velocity before freezing
                                    ball.pausedVelocity = Vector.clone(ball.velocity);
                                    ball.pausedAngularVelocity = ball.angularVelocity;
                                    Matter.Body.setStatic(ball, true);
                                }
                            });
                        }
                    } else if (!aiming && !turnInProgress && usedBalls.length > 0) { // Start Initial Aim
                        aiming = true; isPausing = false;
                    }
                }
                // --- Right Click Logic (Restart/Speed Toggle) ---
                else if (e.button === 2) {
                    e.preventDefault(); // Prevent context menu regardless of game state

                    if (gameOver) {
                        // If game is over, right-click restarts
                        restartGame();
                    } else {
                        // If game is active, handle double-click for speed toggle
                        const currentTime = Date.now();
                        const timeDiff = currentTime - lastRightClickTime;

                        if (timeDiff < DOUBLE_CLICK_THRESHOLD) {
                            // Double click detected during active game
                            if (!isPausing) { // Only toggle speed if not paused
                                isSpedUp = !isSpedUp;
                                engine.timing.timeScale = isSpedUp ? 3 : 1;
                                console.log(`Game speed toggled. Time scale: ${engine.timing.timeScale}`);
                            }
                            // Reset time to prevent triple+ clicks counting as double
                            lastRightClickTime = 0;
                        } else {
                            // First click (or click after threshold) during active game
                            lastRightClickTime = currentTime;
                        }
                    }
                }
             });

            render.canvas.addEventListener('mousemove', (e) => {
                 // Update mouse position only if aiming initially or if pausing (to show aim line during pause)
                 if ((aiming || isPausing) && !gameOver) mousePos = { x: e.offsetX, y: e.offsetY };
            });

            render.canvas.addEventListener('mouseup', (e) => {
                if (gameOver || e.button !== 0) return; // Only process left mouse button release during active game
                const endPos = { x: e.offsetX, y: e.offsetY };

                if (isPausing) { // --- Resume from Pause with RE-AIM ---
                    isPausing = false; // Pause finished
                    console.log("Resuming turn with re-aim attempt.");

                    // Calculate the NEW launch direction based on mouse release ONCE
                    const direction = Vector.sub(endPos, startPos);
                    const magnitudeSquared = Vector.magnitudeSquared(direction);
                    let newLaunchVelocity = null;
                    let reAimIsValid = false;

                    // Validate the re-aim direction (similar to initial launch)
                    if (direction.y > -50 && magnitudeSquared > 20 * 20) { // Check minimum drag and downward direction
                        const angle = Math.atan2(direction.y, direction.x);
                        if (!(angle > -Math.PI * 0.95 && angle < -Math.PI * 0.05)) { // Check angle is not too upward
                            // Re-aim is valid, calculate the velocity vector
                            newLaunchVelocity = Vector.mult(Vector.normalise(direction), LAUNCH_MAGNITUDE);
                            reAimIsValid = true;
                            console.log(`Re-aim Direction Valid. New Velocity: {x: ${newLaunchVelocity.x.toFixed(2)}, y: ${newLaunchVelocity.y.toFixed(2)}}`);
                            // **** CORE FIX: Update the turn's active launchDirection ****
                            launchDirection = Vector.clone(newLaunchVelocity); // Store the *new* direction globally for the turn
                            // ***********************************************************
                        } else {
                            console.log("Re-aim cancelled - invalid angle (too upward). Restoring original velocity.");
                        }
                    } else {
                        console.log("Re-aim cancelled - drag distance/direction invalid. Restoring original velocity.");
                    }

                    // Unfreeze the balls and apply either the NEW or ORIGINAL velocity
                    const ballsToProcess = balls.slice(); // Process currently active balls
                    ballsToProcess.forEach((ball) => {
                        // Only unfreeze balls that were actually paused (have stored velocity)
                        if (ball.isStatic && !ball.isSettled && !ball.isUsed && ball.pausedVelocity) {
                             Matter.Body.setStatic(ball, false); // Unfreeze first

                             if (reAimIsValid && newLaunchVelocity) { // Check the flag and that velocity exists
                                 // Apply the NEW velocity from re-aim
                                 Matter.Body.setVelocity(ball, newLaunchVelocity); // Use the newly calculated velocity
                                 Matter.Body.setAngularVelocity(ball, (Math.random() - 0.5) * 0.05); // Give a little spin
                             } else {
                                 // Apply the ORIGINAL stored velocity if re-aim was invalid
                                 Matter.Body.setVelocity(ball, ball.pausedVelocity);
                                 Matter.Body.setAngularVelocity(ball, ball.pausedAngularVelocity || 0);
                             }
                             // Clear the stored properties regardless
                             delete ball.pausedVelocity;
                             delete ball.pausedAngularVelocity;
                        } else if (ball.isStatic && !ball.isSettled && !ball.isUsed) {
                             // Fallback if pausedVelocity wasn't stored (shouldn't happen often)
                             console.warn(`Ball ${ball.id} was static but had no pausedVelocity. Unfreezing only.`);
                             Matter.Body.setStatic(ball, false);
                             delete ball.pausedVelocity; // Clean up just in case
                             delete ball.pausedAngularVelocity;
                        }
                    });
                    // Turn remains in progress
                    pauseResumeGraceTicks = PAUSE_RESUME_GRACE_TICKS_TOTAL; // Apply grace period after resuming

                } else if (aiming) { // --- Execute Initial Launch ---
                    aiming = false; // Aiming phase is over
                    const direction = Vector.sub(endPos, startPos); const magnitudeSquared = Vector.magnitudeSquared(direction);
                    // Check for valid launch direction (not too shallow, sufficient drag distance)
                    if (direction.y > -50 && magnitudeSquared > 40 * 40) { // Ensure some downward component and minimum drag
                        const angle = Math.atan2(direction.y, direction.x);
                        // Prevent launching almost straight up or into the top corners
                        if (!(angle > -Math.PI * 0.95 && angle < -Math.PI * 0.05)) {
                            turnInProgress = true; pauseResumeGraceTicks = 0; // Reset grace ticks on new launch
                            const initialLaunchDirection = Vector.mult(Vector.normalise(direction), LAUNCH_MAGNITUDE);
                            // *** STORE the initial direction for this turn ***
                            launchDirection = initialLaunchDirection;
                            console.log(`Initial Launch. Turn Direction Set: {x: ${launchDirection.x.toFixed(2)}, y: ${launchDirection.y.toFixed(2)}}`);

                            const countToLaunch = Math.min(usedBalls.length, currentLaunchCount);
                            if (countToLaunch === 0) { console.error("Launch Error: No balls available!"); turnInProgress = false; return; }
                            console.log(`Launching ${countToLaunch} balls.`);
                            const ballsToLaunch = usedBalls.splice(0, countToLaunch);

                            // Launch balls with stagger
                            ballsToLaunch.forEach((ball, index) => {
                                balls.push(ball); ball.isSettled = false; ball.isUsed = false;
                                // Clear any potential leftover pause state (shouldn't happen but safe)
                                delete ball.pausedVelocity;
                                delete ball.pausedAngularVelocity;
                                ball.render.fillStyle = ACTIVE_BALL_COLOR; // Set standard active color

                                setTimeout(() => { // Stagger launch timing
                                    if (!gameOver && !isPausing) { // Check isPausing here too, unlikely but prevents weirdness
                                        Matter.Body.setPosition(ball, startPos); Matter.Body.setStatic(ball, false);
                                        // Use the stored launchDirection determined at the start of this launch sequence
                                        Matter.Body.setVelocity(ball, launchDirection); // Use the consistent direction stored for the turn
                                        Matter.Body.setAngularVelocity(ball, (Math.random() - 0.5) * 0.05);
                                    }
                                }, index * 80); // 80ms stagger between balls
                            });
                        } else { console.log("Initial launch cancelled - invalid angle (too upward)."); turnInProgress = false; } // Ensure turn doesn't start if cancelled
                    } else { console.log("Initial launch cancelled - drag distance/direction invalid."); turnInProgress = false; } // Ensure turn doesn't start if cancelled
                }
            });

            // Prevent context menu on right-click (handled in mousedown)
            render.canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); });

             // --- Rendering Logic (After Update) ---
            Events.on(render, 'afterRender', function() {
                try {
                    const context = render.context;
                    context.globalCompositeOperation = 'source-over'; // Ensure normal drawing mode

                    // Custom Polygon Text Rendering
                    polygons.forEach(poly => {
                        if (poly.render && poly.render.textValue && !poly.isDiamond) {
                            context.font = `${poly.render.textSize || 12}px ${poly.render.textFont || 'Arial'}`;
                            context.fillStyle = poly.render.textColor || '#ffffff';
                            context.textAlign = 'center'; context.textBaseline = 'middle';
                            context.fillText(poly.render.textValue, poly.position.x, poly.position.y);
                        }
                    });

                    // Cage Line Drawing
                    if (!gameOver) {
                        context.beginPath(); context.strokeStyle = '#CC0000'; context.lineWidth = CAGE_LINE_WIDTH; context.setLineDash([]);
                        const leftLineEndX = startPos.x - CAGE_GAP_WIDTH / 2; context.moveTo(0, CAGE_Y_POSITION); context.lineTo(leftLineEndX, CAGE_Y_POSITION);
                        const rightLineStartX = startPos.x + CAGE_GAP_WIDTH / 2; context.moveTo(rightLineStartX, CAGE_Y_POSITION); context.lineTo(CANVAS_WIDTH, CAGE_Y_POSITION); context.stroke();
                     }

                    // Aiming Line Drawing (Visible during initial aim AND pause)
                    if ((aiming || isPausing) && !gameOver) {
                        context.beginPath(); context.strokeStyle = '#000000'; context.lineWidth = 2; context.setLineDash([10, 5]);
                        const dx = mousePos.x - startPos.x; const dy = mousePos.y - startPos.y;
                        // Only draw if aiming generally downwards and not straight up/corners
                        if (dy > -50) {
                            const angle = Math.atan2(dy, dx);
                            if (!(angle > -Math.PI * 0.95 && angle < -Math.PI * 0.05)) {
                                const length = Math.min(Math.sqrt(dx * dx + dy * dy), 200); // Limit line length
                                context.moveTo(startPos.x, startPos.y); context.lineTo(startPos.x + Math.cos(angle) * length, startPos.y + Math.sin(angle) * length); context.stroke();
                            }
                        }
                        context.setLineDash([]); // Reset dash pattern
                     }
                } catch (error) { console.error('Rendering error:', error); }
             });

            // --- Restart Game Function ---
             function restartGame() {
                 console.log("Executing restartGame...");
                if (scoreFlashInterval) clearInterval(scoreFlashInterval); scoreFlashInterval = null;
                // Clear world and engine
                World.clear(world); Engine.clear(engine);
                 // Reset engine properties
                 engine.gravity.y = 1.0;
                 engine.timing.timeScale = 1; // Ensure normal speed on restart
                 isSpedUp = false; // Reset speed up state
                // Reset game state variables
                score = 0; balls = []; usedBalls = []; polygons = [];
                gameOver = false; aiming = false; isPausing = false; turnInProgress = false;
                pauseResumeGraceTicks = 0; // Reset grace on restart
                currentLaunchCount = 1; nextRoundBallCount = 1; round = 1; rowCount = 0; launchDirection = null;
                startPos = { x: FIXED_START_X, y: 20 };
                lastRightClickTime = 0; // Reset double click timer
                // Reset UI elements
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('scoreDisplay').style.display = 'none';
                document.getElementById('scoreDisplay').style.visibility = 'visible';
                // Restore original game over text in case it was changed
                document.getElementById('gameOver').innerHTML = 'GAME OVER';
                updateBanner();
                // Re-add world boundaries
                World.add(world, [
                     Bodies.rectangle(3, CANVAS_HEIGHT / 2, 4, CANVAS_HEIGHT, { isStatic: true, restitution: 0.8, friction: 0.0, collisionFilter: { category: defaultCategory, mask: ballCategory } }),
                     Bodies.rectangle(351, CANVAS_HEIGHT / 2, 4, CANVAS_HEIGHT, { isStatic: true, restitution: 0.8, friction: 0.0, collisionFilter: { category: defaultCategory, mask: ballCategory } }),
                     Bodies.rectangle(CANVAS_WIDTH / 2, CANVAS_HEIGHT + 30, CANVAS_WIDTH, 60, { isStatic: true, isSensor: true, label: 'bottomSensor', collisionFilter: { category: defaultCategory, mask: ballCategory } })
                ]);
                // Add initial ball(s) and polygon row
                for (let i = 0; i < currentLaunchCount; i++) createBall(startPos.x, startPos.y, true);
                createPolygonRow(CANVAS_HEIGHT - ROW_HEIGHT);
                console.log("Game restarted. Ready balls:", usedBalls.length);
            }
             // Add keyboard listener for restart (R key) - kept as alternative
             window.addEventListener('keydown', (e) => { if (!e.repeat && (e.key === 'r' || e.key === 'R')) restartGame(); });

            // --- End Turn Logic ---
            function endTurn() {
                if (gameOver || isPausing) return; // Should not end turn while paused
                console.log(`Executing endTurn for end of round ${round}.`);
                pauseResumeGraceTicks = 0; // Reset grace period for next turn

                // Reset speed to normal at the end of the turn
                if (isSpedUp) {
                    console.log("Resetting game speed to normal for next round.");
                    isSpedUp = false;
                    engine.timing.timeScale = 1;
                }

                const newBallCount = nextRoundBallCount; console.log(`Next round balls = ${newBallCount}`);

                // Clear existing balls from the world and arrays
                // Clear paused state before removing, just in case
                balls.forEach(b => { delete b.pausedVelocity; delete b.pausedAngularVelocity; });
                usedBalls.forEach(b => { delete b.pausedVelocity; delete b.pausedAngularVelocity; });
                World.remove(world, usedBalls);
                if (balls.length > 0) {
                    console.warn("Ending turn but active balls remain? Removing them.");
                    World.remove(world, balls);
                 }
                usedBalls = []; balls = [];

                // Create new balls for the next round, respecting MAX_OBJECTS limit
                const ballsToCreate = Math.min(newBallCount, MAX_OBJECTS - polygons.length);
                startPos.x = FIXED_START_X; // Reset start position X
                for (let i = 0; i < ballsToCreate; i++) createBall(startPos.x, startPos.y, true); // Create as 'used' (ready)
                if (ballsToCreate < newBallCount) console.warn(`Ball creation capped at ${ballsToCreate} due to object limit.`);

                // Move existing polygons up
                polygons.forEach(poly => Matter.Body.translate(poly, { x: 0, y: -ROW_HEIGHT }));

                // Check for game over immediately after moving polygons
                for (const poly of polygons) {
                    if (poly.position.y - POLYGON_RADIUS < CAGE_Y_POSITION) {
                        // Use setTimeout to ensure render catches up before triggering game over visually
                        setTimeout(() => triggerGameOver(`Polygon reached cage line after move`), 50);
                        return; // Stop further end-turn logic if game over
                    }
                }

                // Add a new row of polygons if not game over and space allows
                if (!gameOver && polygons.length < MAX_OBJECTS * 0.8) {
                    createPolygonRow(CANVAS_HEIGHT - ROW_HEIGHT);
                }

                // Update state for the new round
                currentLaunchCount = ballsToCreate; nextRoundBallCount = ballsToCreate; round++;
                turnInProgress = false; aiming = false; isPausing = false; launchDirection = null; // Clear active launch direction for the new turn
                updateBanner();
                console.log(`Starting round ${round}. Balls available: ${currentLaunchCount}. Ready balls: ${usedBalls.length}`);
            }

            // --- Start the Game ---
            Engine.run(engine);
            Render.run(render);
            console.log("Game Initialized. Engine and Renderer running.");

        } catch (error) {
            console.error('Game failed to initialize:', error);
            document.body.innerHTML += `<p style="color: red; position: absolute; top: 100px; left: 10px; background: white; padding: 10px; border: 1px solid black;">Error loading game: ${error.message}. Check console.</p>`;
        }
    </script>
</body>
</html>